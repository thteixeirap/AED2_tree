<mxfile host="app.diagrams.net" modified="2022-01-17T13:39:45.580Z" agent="5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36 Edg/97.0.1072.62" etag="zQzxL-UCfwY2QfIQLPFW" version="16.2.7" type="github">
  <diagram name="Page-1" id="42789a77-a242-8287-6e28-9cd8cfd52e62">
    <mxGraphModel dx="1038" dy="547" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1" pageWidth="1100" pageHeight="850" background="none" math="0" shadow="0">
      <root>
        <mxCell id="0" />
        <mxCell id="1" parent="0" />
        <mxCell id="430OXLAYMfgtic5GREOD-2" value="" style="ellipse;whiteSpace=wrap;html=1;aspect=fixed;" vertex="1" parent="1">
          <mxGeometry x="320" y="155" width="50" height="50" as="geometry" />
        </mxCell>
        <mxCell id="430OXLAYMfgtic5GREOD-4" value="" style="ellipse;whiteSpace=wrap;html=1;aspect=fixed;" vertex="1" parent="1">
          <mxGeometry x="420" y="45" width="50" height="50" as="geometry" />
        </mxCell>
        <mxCell id="430OXLAYMfgtic5GREOD-5" value="" style="ellipse;whiteSpace=wrap;html=1;aspect=fixed;" vertex="1" parent="1">
          <mxGeometry x="420" y="255" width="50" height="50" as="geometry" />
        </mxCell>
        <mxCell id="430OXLAYMfgtic5GREOD-6" value="" style="ellipse;whiteSpace=wrap;html=1;aspect=fixed;" vertex="1" parent="1">
          <mxGeometry x="600" y="45" width="50" height="50" as="geometry" />
        </mxCell>
        <mxCell id="430OXLAYMfgtic5GREOD-7" value="" style="ellipse;whiteSpace=wrap;html=1;aspect=fixed;" vertex="1" parent="1">
          <mxGeometry x="600" y="255" width="50" height="50" as="geometry" />
        </mxCell>
        <mxCell id="430OXLAYMfgtic5GREOD-9" value="" style="ellipse;whiteSpace=wrap;html=1;aspect=fixed;" vertex="1" parent="1">
          <mxGeometry x="710" y="155" width="50" height="50" as="geometry" />
        </mxCell>
        <mxCell id="430OXLAYMfgtic5GREOD-10" value="" style="endArrow=none;html=1;rounded=0;entryX=0;entryY=1;entryDx=0;entryDy=0;exitX=0.5;exitY=0;exitDx=0;exitDy=0;" edge="1" parent="1" source="430OXLAYMfgtic5GREOD-2" target="430OXLAYMfgtic5GREOD-4">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="350" y="155" as="sourcePoint" />
            <mxPoint x="400" y="105" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="430OXLAYMfgtic5GREOD-14" value="" style="endArrow=none;html=1;rounded=0;exitX=0;exitY=0;exitDx=0;exitDy=0;fillColor=#f8cecc;strokeColor=#b85450;" edge="1" parent="1" source="430OXLAYMfgtic5GREOD-5">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="300" y="255" as="sourcePoint" />
            <mxPoint x="350" y="205" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="430OXLAYMfgtic5GREOD-15" value="" style="endArrow=none;html=1;rounded=0;entryX=0;entryY=0.5;entryDx=0;entryDy=0;fillColor=#f8cecc;strokeColor=#b85450;" edge="1" parent="1" target="430OXLAYMfgtic5GREOD-6">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="470" y="70" as="sourcePoint" />
            <mxPoint x="520" y="25" as="targetPoint" />
            <Array as="points">
              <mxPoint x="490" y="70" />
            </Array>
          </mxGeometry>
        </mxCell>
        <mxCell id="430OXLAYMfgtic5GREOD-16" value="" style="endArrow=none;html=1;rounded=0;entryX=0;entryY=0.5;entryDx=0;entryDy=0;" edge="1" parent="1">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="470" y="279.5" as="sourcePoint" />
            <mxPoint x="600" y="279.5" as="targetPoint" />
            <Array as="points">
              <mxPoint x="490" y="279.5" />
            </Array>
          </mxGeometry>
        </mxCell>
        <mxCell id="430OXLAYMfgtic5GREOD-17" value="" style="endArrow=none;html=1;rounded=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;exitX=1;exitY=1;exitDx=0;exitDy=0;" edge="1" parent="1" source="430OXLAYMfgtic5GREOD-6" target="430OXLAYMfgtic5GREOD-9">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="660" y="75" as="sourcePoint" />
            <mxPoint x="732.3223304703363" y="4.99766952966371" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="430OXLAYMfgtic5GREOD-20" value="" style="endArrow=none;html=1;rounded=0;exitX=1;exitY=0.5;exitDx=0;exitDy=0;entryX=0.5;entryY=1;entryDx=0;entryDy=0;fillColor=#f8cecc;strokeColor=#b85450;" edge="1" parent="1" source="430OXLAYMfgtic5GREOD-7" target="430OXLAYMfgtic5GREOD-9">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="700" y="255" as="sourcePoint" />
            <mxPoint x="750" y="205" as="targetPoint" />
            <Array as="points" />
          </mxGeometry>
        </mxCell>
        <mxCell id="430OXLAYMfgtic5GREOD-21" value="" style="endArrow=none;html=1;rounded=0;exitX=1;exitY=0;exitDx=0;exitDy=0;entryX=0;entryY=1;entryDx=0;entryDy=0;" edge="1" parent="1" source="430OXLAYMfgtic5GREOD-5" target="430OXLAYMfgtic5GREOD-6">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="570" y="145" as="sourcePoint" />
            <mxPoint x="610" y="95" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="430OXLAYMfgtic5GREOD-23" value="" style="endArrow=none;html=1;rounded=0;entryX=0.5;entryY=1;entryDx=0;entryDy=0;exitX=0.5;exitY=0;exitDx=0;exitDy=0;fillColor=#f8cecc;strokeColor=#b85450;" edge="1" parent="1" source="430OXLAYMfgtic5GREOD-5" target="430OXLAYMfgtic5GREOD-4">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="440" y="255" as="sourcePoint" />
            <mxPoint x="490" y="205" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="430OXLAYMfgtic5GREOD-24" value="" style="endArrow=none;html=1;rounded=0;entryX=0.5;entryY=1;entryDx=0;entryDy=0;exitX=0.5;exitY=0;exitDx=0;exitDy=0;fillColor=#f8cecc;strokeColor=#b85450;" edge="1" parent="1">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="624.5" y="255" as="sourcePoint" />
            <mxPoint x="624.5" y="95" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="430OXLAYMfgtic5GREOD-25" value="S" style="text;html=1;align=center;verticalAlign=middle;resizable=0;points=[];autosize=1;strokeColor=none;fillColor=none;" vertex="1" parent="1">
          <mxGeometry x="335" y="170" width="20" height="20" as="geometry" />
        </mxCell>
        <mxCell id="430OXLAYMfgtic5GREOD-26" value="B" style="text;html=1;align=center;verticalAlign=middle;resizable=0;points=[];autosize=1;strokeColor=none;fillColor=none;" vertex="1" parent="1">
          <mxGeometry x="435" y="60" width="20" height="20" as="geometry" />
        </mxCell>
        <mxCell id="430OXLAYMfgtic5GREOD-27" value="D" style="text;html=1;align=center;verticalAlign=middle;resizable=0;points=[];autosize=1;strokeColor=none;fillColor=none;" vertex="1" parent="1">
          <mxGeometry x="615" y="60" width="20" height="20" as="geometry" />
        </mxCell>
        <mxCell id="430OXLAYMfgtic5GREOD-28" value="T" style="text;html=1;align=center;verticalAlign=middle;resizable=0;points=[];autosize=1;strokeColor=none;fillColor=none;" vertex="1" parent="1">
          <mxGeometry x="725" y="170" width="20" height="20" as="geometry" />
        </mxCell>
        <mxCell id="430OXLAYMfgtic5GREOD-29" value="E" style="text;html=1;align=center;verticalAlign=middle;resizable=0;points=[];autosize=1;strokeColor=none;fillColor=none;" vertex="1" parent="1">
          <mxGeometry x="615" y="270" width="20" height="20" as="geometry" />
        </mxCell>
        <mxCell id="430OXLAYMfgtic5GREOD-30" value="C" style="text;html=1;align=center;verticalAlign=middle;resizable=0;points=[];autosize=1;strokeColor=none;fillColor=none;" vertex="1" parent="1">
          <mxGeometry x="435" y="270" width="20" height="20" as="geometry" />
        </mxCell>
        <mxCell id="430OXLAYMfgtic5GREOD-32" value="4" style="text;html=1;align=center;verticalAlign=middle;resizable=0;points=[];autosize=1;strokeColor=none;fillColor=none;rotation=0;" vertex="1" parent="1">
          <mxGeometry x="370" y="105" width="20" height="20" as="geometry" />
        </mxCell>
        <mxCell id="430OXLAYMfgtic5GREOD-33" value="5" style="text;html=1;align=center;verticalAlign=middle;resizable=0;points=[];autosize=1;strokeColor=none;fillColor=none;" vertex="1" parent="1">
          <mxGeometry x="520" y="40" width="20" height="20" as="geometry" />
        </mxCell>
        <mxCell id="430OXLAYMfgtic5GREOD-34" value="6" style="text;html=1;align=center;verticalAlign=middle;resizable=0;points=[];autosize=1;strokeColor=none;fillColor=none;rotation=0;" vertex="1" parent="1">
          <mxGeometry x="690" y="105" width="20" height="20" as="geometry" />
        </mxCell>
        <mxCell id="430OXLAYMfgtic5GREOD-35" value="1" style="text;html=1;align=center;verticalAlign=middle;resizable=0;points=[];autosize=1;strokeColor=none;fillColor=none;" vertex="1" parent="1">
          <mxGeometry x="430" y="155" width="20" height="20" as="geometry" />
        </mxCell>
        <mxCell id="430OXLAYMfgtic5GREOD-36" value="2" style="text;html=1;align=center;verticalAlign=middle;resizable=0;points=[];autosize=1;strokeColor=none;fillColor=none;" vertex="1" parent="1">
          <mxGeometry x="690" y="235" width="20" height="20" as="geometry" />
        </mxCell>
        <mxCell id="430OXLAYMfgtic5GREOD-37" value="10" style="text;html=1;align=center;verticalAlign=middle;resizable=0;points=[];autosize=1;strokeColor=none;fillColor=none;" vertex="1" parent="1">
          <mxGeometry x="515" y="285" width="30" height="20" as="geometry" />
        </mxCell>
        <mxCell id="430OXLAYMfgtic5GREOD-38" value="2" style="text;html=1;align=center;verticalAlign=middle;resizable=0;points=[];autosize=1;strokeColor=none;fillColor=none;" vertex="1" parent="1">
          <mxGeometry x="370" y="235" width="20" height="20" as="geometry" />
        </mxCell>
        <mxCell id="430OXLAYMfgtic5GREOD-39" value="8&lt;br&gt;" style="text;html=1;align=center;verticalAlign=middle;resizable=0;points=[];autosize=1;strokeColor=none;fillColor=none;" vertex="1" parent="1">
          <mxGeometry x="525" y="150" width="20" height="20" as="geometry" />
        </mxCell>
        <mxCell id="430OXLAYMfgtic5GREOD-167" value="" style="swimlane;startSize=0;" vertex="1" parent="1">
          <mxGeometry x="430" y="8920" width="420" height="200" as="geometry" />
        </mxCell>
        <mxCell id="430OXLAYMfgtic5GREOD-166" value="&lt;h1 align=&quot;center&quot;&gt; &#xa; Trabalho AEDS|CEFET &#xa;&lt;/h1&gt;&#xa;&#xa;&lt;h4 align=&quot;center&quot;&gt;	&#xa;  Esse projeto é uma aplicação que seleciona a partir dos dados dos produtos dos mercados (varejos em geral) cadastrados os melhores preços escolhidos pelo usuário, imprimindo e criando um arquivo .txt dos resultados obtidos &#xa;&lt;/h4&gt;&#xa;&lt;h1&gt;&lt;/h1&gt;&#xa;&#xa;&lt;!--ts--&gt;&#xa;* [Sobre](#Sobre)&#xa;&#xa;* [Como funciona](#rockey-Como-funciona)&#xa;&#xa;* [Pré requisitos](#computer-Pré-requisitos)&#xa;&#xa;* [Execução dos testes | Descrição do Programa](#gear-Execução-dos-testes)    &#xa;	&#xa;	* [Abertura dos arquivos](#Abertura-da-pasta-dos-arquivos)&#xa;&#xa;	* [Menu](#Menu) &#xa; &#xa;* [Custo computacional](#wrench-Custo-computacional)&#xa; &#xa;	* [Leitura inicial dos arquivos](#Leitura-inicial-dos-arquivos-txt-cadastrados)&#xa;&#xa;	* [Opção 1](#Opção-1)&#xa;	&#xa;	* [Opção 2](#Opção-2)&#xa;&#xa;	* [Opção 3](#Opção-3)&#xa;&#xa;	* [Custo total](#Custo-total)&#xa;	&#xa;* [Autores](#Autores)&#xa;	&#xa; &lt;!--te--&gt;  &#xa;&#xa;&#xa;## Sobre &#xa;&#xa;  Nos dias atuais a necessidade de otimização do tempo tem sido primordial devido a rotina cada vez mais acelerada. Devido à essa falta de tempo, muitas das vezes, as pessoas não têm a possibilidade de comparar preços, deixando de economizar um dinheiro que parece pouco em um primeiro momento, mas que ao longo do tempo poderá fazer falta.&#xa;Portanto, avaliando essa necessidade, surge a proposta de um sistema que permite a partir dos interesses de compra do usuário, a busca dos produtos de melhores preço, ecomizando tanto o tempo quanto o dinheiro desse usuário. Diante desse fato, e seguindo alguns sistemas já criado como presente nos sites [Zoom](https://www.zoom.com.br) e [Buscapé](https://www.buscape.com.br) nossa aplicação tem como objetivo buscar essa facilitação para esse usuário.&lt;p&gt;&#xa;&#xa; - Desafios a serem cumpridos:&#xa; &#xa;:heavy_check_mark: Lista estática&#xa;&#xa;:heavy_check_mark: Lista dinâmica&#xa;&#xa;:heavy_check_mark: Ordenação: QuickShort &#xa;&#xa;&#xa;## :rocket: Como funciona&#xa;&#xa;&lt;p&gt; Na pasta Mercados criasse arquivos .txt para cada mercado, tendo como o nome o proprio nome do mercado. Dentro desses arquivos estão os dados dos diferentes tipos de produtos cadastrados contendo o identificador, nome e preço do mesmo. Ao iniciar o programa o usuário insere um arquivo contendo as informações de todos esses mercados presente nessa pasta, no qual a partir da escolha do usuário o programa irá fazer uma busca e encontrar dentre esse mercados o produto com o menor preço e apresenta-lo a partir de um arquivo criado&lt;p&gt;&#xa;&#xa;&#xa;## :computer: Pré-requisitos&#xa;	&#xa;- Programa feito utilizando linguaguem C &#xa;	&#xa;- IDE utilizado : Visual Studio Code &#xa;	&#xa;- Sistema operacional: Windows 10&#xa;	&#xa;&#xa;- Execução: Foi criado um arquivo bat (compila.bat) para compilar o arquivo e não ser necessário abrir prompt.&#xa;&#xa;&gt; :grey_exclamation: Criando o arquivo executável a partir do compila.bat :&#xa;	&#xa;![WhatsApp Video 2021-09-07 at 12 57 28 PM](https://user-images.githubusercontent.com/78819692/132376065-cb3b814f-343b-4397-a613-1cae7eaf40bc.gif)&#xa;&#xa;	&#xa;&#xa;&#xa;## :gear: Execução dos testes&#xa;&lt;p&gt;Execução do programa a partir do arquivo &#39;teste&#39; presente no repositório&lt;p&gt;&#xa;&#xa;&#xa;&lt;p&gt;Após a abertura do arquivo .txt no qual contém os ID&#39;s e nomes dos mercados cadastrados, o programa realiza a tokenização dos nomes de cada mercado presente, (no qual contém um arquivo .txt para cada um com os dados dos produto) e faz o encaminhamento para a pasta Mercados e realiza a leitura desses arquivos.&lt;p&gt;&#xa;&#xa;	&#xa;### Abertura da pasta dos arquivos&#xa;	&#xa;```sh&#xa;    char cwd[MAX_TAM];&#xa;	getcwd(cwd, sizeof(cwd));&#xa;```&#xa;- Usando a função getcwd pertencente a biblioteca &lt;unistd.h&gt;, pegamos o caminho do diretório no qual encontra a pasta do projeto e armazenamos na variavel cwd. &#xa;	&#xa;```sh&#xa;	int opera=0;&#xa;    	char *token;&#xa;    	char leitor[MAX_TAM];&#xa;	&#xa;	while((fgets(leitor,MAX_TAM,f_Mercados)!=NULL))&#xa;	{&#xa;	char abre_mercado[MAX_TAM];&#xa;        strcpy(abre_mercado,cwd);&#xa;        strcat(abre_mercado,&quot;\\Mercados\\&quot;);&#xa;	token=strtok(leitor,&quot;-&gt;&quot;);&#xa;&#xa;        while(token!=NULL)&#xa;        {        &#xa;            char copia[MAX_TAM];&#xa;            strcpy(copia,token);&#xa;&#xa;            if(opera==0)&#xa;            {&#xa;            	int ID;                &#xa;            	ID=atoi(copia);&#xa;                m[cont_mercados].ID_mercado=ID;&#xa;                opera++;&#xa;            }else&#xa;            {   &#xa;                if(opera==1)&#xa;                {&#xa;                	strcpy(m[cont_mercados].nome_mercado,token);&#xa;                	opera++;&#xa;				}&#xa;				else&#xa;				{&#xa;					opera=0;&#xa;					break;&#xa;				}&#xa;            }         &#xa;            token=strtok(NULL,&quot;-&gt;&quot;);&#xa;        }		&#xa;        strcat(abre_mercado,m[cont_mercados].nome_mercado);&#xa;        strcat(abre_mercado,txt);&#xa;        Recebe_Produto(&amp;m[cont_mercados],abre_mercado);&#xa;	cont_mercados++;	&#xa;	}&#xa;```  &#xa;- Dentro do primeiro While iremos ler todo conteúdo do arquivo inserido (teste), no qual foi utilizado na tokenização o separador &lt;strong&gt;-&gt;&lt;/strong&gt;.&#xa;- A variável &quot;abre_mercado&quot; recebe cwd e é adicionado &quot;\\\Mercaodos\\\&quot; no final dessa string, tendo assim salva o endereço dentro da pasta Mercados.&#xa;- O segundo While varre linha por linha do arquivo, sendo sempre o primeiro token o ID e o segundo token o nome do mercado, adicionando ambos em uma lista estática.&#xa;- Ao final do primeiro While, é adicionado a variável em que contém o endereço da pasta Mercados (abre_mercado) o nome do mercado e o .txt, tendo assim o endereço do arquivo .txt dos dados mercado de cada um, sendo o nome desses arquivos o proprio nome do mercado.&#xa;- Chamamos a função Recebe_Produto para todo nome de mercado recebido, no qual é usado na tokenização o mesmo separador &lt;strong&gt;-&gt;&lt;/strong&gt;, tendo a ordem a cada linha percorrida o ID, nome do produto e o preço.&#xa;##### Modelo arquivo mercado :&#xa;![mercado](https://user-images.githubusercontent.com/78819692/131039101-6015c913-34d5-4353-8431-84b1d131f9e9.png)&#xa;&#xa;&#xa;	&#xa;### Menu &#xa;&#xa;![Menu](https://user-images.githubusercontent.com/78819692/131042136-760cca43-21f5-4084-a0d6-8f1ee5d4e029.png)&#xa;&#xa;:point_right: Opção 1:&#xa;	&#xa;&lt;p&gt;O usuário insere produto por produto, no qual será avaliado o de melhor preço entre os mercados cadastrados e adicionado em sua lista de compras (Lista dinâmica)&lt;p&gt;&#xa;	&#xa;- Procura pelo melhor preço:&#xa;&lt;p&gt;A função Consulta_Menor_Preco é realizada usando o método &lt;strong&gt;QuickShort&lt;/strong&gt;, no qual sempre após encontrando o produto de menor custo entre os mercados cadastrados, adiciona na lista de compras no fim do método&lt;p&gt;&#xa;	&#xa;:point_right: Opção 2:&#xa;	&#xa;&lt;p&gt;O usuário entra com o arquivo .txt com os nomes dos produtos escolhidos para a seleção de melhor preço &lt;p&gt;&#xa;	&#xa;![op2](https://user-images.githubusercontent.com/78819692/131122060-23e9a0e6-e378-4dc0-8fb9-a1094c3d9b5a.png)&#xa;	&#xa;#### Exemplo Lista &#xa;	&#xa;![listacompra](https://user-images.githubusercontent.com/78819692/131122233-194ddf01-169f-4094-847a-0ac6f75f861b.png)&#xa;	&#xa;&lt;p&gt;É utilizado no final de cada item da lista o separador -&gt;, no qual servirá de auxilio na execução da tokenização desse arquivo&lt;p&gt;&#xa;	&#xa;:point_right: Opção 3:&#xa;	&#xa;&lt;p&gt;Após inserir os produtos escolhidos, seja usando a opção 1 ou a opção 2, é criado um arquivo .txt (Lista de Compras.txt) na área de trabalho contendo em qual mercado cada produto se encontra com o menor preço e o ranking dos mercados melhor avaliado de acordo com o preço dos itens selecionados.&lt;p&gt;&#xa;&lt;p&gt; O ranking está programado a partir da quantidade de mercados cadastrados. &#xa; Caso esse número for menor que 15, iremos ter o ranking dos 5 melhores mercados.&#xa; Caso esse número for igual ou maior que 15, iremos ter o ranking de 40% do número dos mercados cadastrados.&#xa; Caso tiver mais de 40 mercados cadastrados, iremos ter a quantidade fixa de 10 mercados avaliados no ranking.&lt;/p&gt;&#xa;&#xa;- Exemplo da Lista de Compras gerado a partir da Lista inserida na opção 2:&#xa;	&#xa;&#xa;&lt;img src=&quot;https://user-images.githubusercontent.com/78819692/131125390-f90bbe4a-5bf2-4c56-b9f4-7cdd84f7dbe9.png&quot; width=&quot;400&quot;&gt;&#xa;	&#xa;## :wrench: Custo computacional&#xa;	&#xa;#### Leitura inicial dos arquivos .txt cadastrados&#xa;	&#xa;&gt; :exclamation: Trecho de código pertencente a função `Recebe_Mercado`:	&#xa;&#xa;```sh&#xa; while((fgets(leitor,MAX_TAM,f_Mercados)!=NULL))&#xa;	{&#xa;	char abre_mercado[MAX_TAM]; //+1&#xa;        strcpy(abre_mercado,cwd); //+1&#xa;        strcat(abre_mercado,&quot;\\Mercados\\&quot;); //+1&#xa;	token=strtok(leitor,&quot;-&gt;&quot;); //+1&#xa;	&#xa;        while(token!=NULL) &#xa;        {        &#xa;            char copia[MAX_TAM];   &#xa;            strcpy(copia,token);   //+2 todo loop&#xa;	 	&#xa;            if(opera==0)   &#xa;            { &#xa;            	int ID;                &#xa;            	ID=atoi(copia);  &#xa;                m[cont_mercados].ID_mercado=ID;  &#xa;                opera++;  // Custo IF = +5 (Comparação,Declaração,3 ações variaveis) &#xa;            }else&#xa;            {   &#xa;                if(opera==1)&#xa;                {&#xa;                	strcpy(m[cont_mercados].nome_mercado,token);&#xa;                	opera++; // Custo IF = +4 (Compação 1 If, Comparação 2 If, strcpy, soma)&#xa;				}&#xa;				else&#xa;				{&#xa;					opera=0;&#xa;					break;  //Custo Else +4 (Compação 1 If, Comparação 2 If, ação variavel, break) &#xa;				}&#xa;            }&#xa;            token=strtok(NULL,&quot;-&gt;&quot;);&#xa;        }&#xa;		&#xa;        strcat(abre_mercado,m[cont_mercados].nome_mercado);  //+1&#xa;        strcat(abre_mercado,txt);  //+1&#xa;        Recebe_Produto(&amp;m[cont_mercados],abre_mercado);  //+27&#xa;	cont_mercados++;  //+1	&#xa;	}&#xa;```&#xa;	&#xa;- Dentro da função Recebe_Mercado iremos fazer a leitura inicial dos mercados cadastrados. Analisando o trecho de maior custo dentro dessa função, na qual esta em função de N (números de mercados cadastrados) temos no primeiro While N loops a serem processados.Em um primeiro momento, ignorando o segundo While, temos como custo computacional de 7 + 27P nesse primeiro While ( 7 com ações simples de custo singular e 27P da função `Recebe_Produto`, função essa a ser demostrada) Sendo igual a 7 + 27P.&#xa;&#xa;- No segundo While, teremos 3 tokens por mercado cadastrado (ID,nome,&quot;quebra-linha) ou seja, 3N. Calculando as 3 entradas nesse while, vemos que na primeira entrada (Condição do primeiro IF) teremos o custo de +7, na segunda entrada ( Condição do 2 IF) o custo de +6 e na ultima entrada o custo de +6 somando assim um total de 19 de custo, que somado com +3 do strtok a cada loop. Portanto a cada mercado cadastrado teremos 22 de custo nesse While, que é igual a 22 &lt;p&gt;&#xa;	&#xa;- Portanto, somando esses custos, temos o custo para a leitura inicial desses arquivos de  (22 + 7) N * 27P = &lt;strong&gt;29N * 27P&lt;/strong&gt;&#xa;		&#xa;   &#xa;&#xa;&gt; :exclamation: Trecho de código pertencente a função `Recebe_Produto` :&#xa;	&#xa;```sh&#xa;while(fgets(leitor,MAX_TAM,f_Mercado)!=NULL) // Le P vezes ( P = qtidade de produtos em cada mercado)&#xa;    {&#xa;        int ID; &#xa;        float Valor;&#xa;        char Nome[MAX_TAM];&#xa;        token=strtok(leitor,&quot;-&gt;&quot;);//+4&#xa;       &#xa;        while(token!=NULL) // ENTRA 3 tokens a cada produto (ID, nome, preço)&#xa;        {   &#xa;            strcpy(copia,token); 			&#xa;            if(operador==0) &#xa;            {             &#xa;                ID=atoi(copia);&#xa;                operador++;&#xa;            } //CUSTO PRA CHEGAR NESSE IF = +4 (strcpy, comparação, 2 açoes variavel)&#xa;            else&#xa;            {&#xa;                if (operador==1)&#xa;                {&#xa;                    strcpy(Nome,token);                  &#xa;                    operador++;&#xa;                }//CUSTO PRA CHEGAR NESSE IF = +5 (strcpy, comparação 1 If,comparação 2 if,strcpy,soma)&#xa;                else&#xa;                {&#xa;                    Valor=atof(copia);&#xa;                    operador=0;&#xa;                }//CUSTO PRA CHEGAR NESSE ELSE = +5 (strcpy, comparação 1 If,comparação 2 if,2 ações variavel)&#xa;&#xa;            }&#xa;            token=strtok(NULL,&quot;-&gt;&quot;); //+1 a cada loop&#xa;        }&#xa;        LInserir(i,ID,Nome,Valor);  //+6     &#xa;	}&#xa;```&#xa;	&#xa;- Dentro da função Recebe_Produto iremos fazer a leitura dos arquivos de cada mercado cadastrado. Isolando o trecho de maior impacto no custo computacional, trecho esse que é  em função de P (sendo P o número de produtos cadastrado nesse mercado) temos o seguintes valores: No primeiro While iremos percorrer todo esse arquivo, no qual, isolando o segundo While interno a esse em um primeiro momento, temos o custo computacional de 10 ( 4 de ações singulares e 6 da função `LInserir`, função responsavel por adicionar os dados de cada produto na lista dinâmica de cada mercado).&#xa;- Analisando o segundo While, temos que a cada produto cadastrado sera realizado 3 loops ( 3 loops pois entrará 3 tokens válidos -ID,nome e preço-). No primeiro loop( Condição válida do primeiro IF) teremos o custo de +5, no segundo loop (condição válida do segundo IF) teremos o custo de +6 e por último o else, tendo o custo de +6. Sendo assim, somamdo&#xa;todos esses loops que irá acontecer a cada produto cadastrado, teremos o custo de 17.&#xa;- Portanto, somando esses custos, temos o custo para a leitura dos arquivos separado de cada mercado de (17+10)*P = &lt;strong&gt;27P&lt;/strong&gt;&#xa;	&#xa;&gt; :warning: A variável P foi usada em todos os mercados para facilitação matemática, cada mercado não necessariamente precisa ter a mesma quantidade de produtos.&#xa;	&#xa;&lt;h1&gt;&lt;/h1&gt;&#xa;	&#xa;#### Opção 1&#xa;	&#xa; Ao escolher a opção 1_(DIGITAR PRODUTOS DA LISTA) a função chamada Consulta_Menor_Preco possui dois trechos de código no qual define seu custo computacional. O primeiro trecho refere-se a estrutura While no qual irá procurar em cada mercado o produto selecionado e adiciona-lo a uma lista estática.&#xa;&#xa;&gt; :exclamation: Trecho de código pertencente a função `Consulta_Menor_Preco` :&#xa;	&#xa;```sh&#xa;	&#xa;   while(cont_linhas&lt;n_linhas) //Entrará N vezes, N = número de mercados&#xa;    {&#xa;        rider=m[cont_linhas].first-&gt;prox;  //+1&#xa;        while(rider!=NULL)  //Irá percorrer todo a lista de produtos do mercado até encontrar &#xa;        {&#xa;            if(strcmp(rider-&gt;p.nome_produto,nome)==0) //+1&#xa;            {                &#xa;                Insere_Produto(&amp;l,rider-&gt;p.valor,m[cont_linhas].ID_mercado,rider-&gt;p.ID_produto,rider-&gt;p.nome_produto,m[cont_linhas].nome_mercado); //6&#xa;                break;&#xa;            }&#xa;            rider=rider-&gt;prox;  //+1&#xa;        }&#xa;        cont_linhas++; //+1&#xa;    }&#xa;```&#xa;	&#xa;- No primeiro While irá percorrer N vezes, sendo N o número de mercados cadastrados. Ignorando o segundo While (interno a esse), temos que a cada loop dessa primeiro While teremos o custo de +2 a cada loop.&#xa;- Já no segundo While (interno) irá percorrer por todos produtos cadastrados ate encontrar o produto selecionado pelo usuário. &lt;strong&gt; Para fins de facilitação matemática iremos considerar a variável P para a quantidade de produtos em todos os mercados e que encontraremos esse produto sempre no meio dessa lista, ou seja, P/2 &lt;/strong&gt;. Sendo assim, esse While irá percorrer P/2 vezes e, a cada loop, irá realizar +2 de custo e, uma vez o IF sendo validado, +6 de custo referente a função `Insere_Produto`.&#xa;- Portanto, o custo geral desse While será de N(2+2P/2+6) = 2N + PN + 6N = &lt;strong&gt;8N + PN&lt;/strong&gt;.&#xa;&#xa;\&#xa;A segunda parte do trecho dentro da função  Consulta_Menor_Preco é logo após o While comentado, em que assim que adicionado dentro da lista as informações do produto (ID,nome,preço) de cada mercado no qual ele se encontra, é chamado a função `Ordena_Crescente`, em que utilizará do modelo de ordenação &lt;strong&gt;QuickShort&lt;/strong&gt; para ordenar o produto em ordem de preço crescente dentro dessa lista &#xa;	&#xa;&#xa; `Ordena_Crescente`:  Utilizando da literatura, sabendo que essa função utiliza-se do método de ordenação &lt;strong&gt;QuickShort&lt;/strong&gt;, temos como caso médio &lt;img src=&quot;https://user-images.githubusercontent.com/78819692/131732133-5f09ebb2-607b-4059-a8f0-746f6ac8501f.png&quot; width=&quot;70&quot;&gt; matematicamente provada como demostrado no site [khanacademy](https://www.khanacademy.org/computing/computer-science/algorithms/quick-sort/a/analysis-of-quicksort). Como N na equação significa a quantidade de elementos dentro dessa lista a ser ordenada e, considerando que cada mercado tem um produto do qual o usuário escolheu, podemos substituir essa variável N como sendo a quantidade de mercados cadastrados.&#xa;	&#xa;- Juntando esses valores, teremos como custo na opção 1 o custo de &lt;img src=&quot;https://user-images.githubusercontent.com/78819692/131744845-d20c8f7e-b214-4b67-88be-9096086eaa10.png&quot; width=&quot;100&quot;&gt; , sendo:&#xa;	&#xa;	&gt; N o número de mercados cadastrados;&#xa;	&#xa;	&gt; P a quantidade de produtos cadastrados em cada mercado;&#xa;	&#xa;	&gt; K a quantidade de produtos escolhidos pelo usuário.&#xa;	&#xa;	&#xa;&lt;h1&gt;&lt;/h1&gt;&#xa;	&#xa;	&#xa;#### Opção 2&#xa;	&#xa;Na opção 2_(INSERIR ARQUIVO COM A LISTA) se difere da opção 1 pois os produtos a serem inseridos pelo usuário será por meio de um arquivo informando os produtos. Portanto, será feito uma tokenização desse arquivo para que assim chamar a função `Consulta_Menor_Preco` estudada na opção 1.&#xa;	&#xa;&gt; :exclamation: Trecho de código pertencente a função `Abre_Lista_De_Compras` :&#xa;	&#xa;```sh&#xa; while(fgets(leitor,MAX_TAM,arquivo)!=NULL)  //3&#xa;    {&#xa;        char Nome[MAX_TAM];&#xa;        int operador=0;&#xa;        token=strtok(leitor,&quot;-&gt;&quot;);&#xa;&#xa;        while(token!=NULL)&#xa;        {   &#xa;            strcpy(Nome,token);			&#xa;            if(operador==0)&#xa;            {&#xa;                Consulta_Menor_Preco(m,Nome,Lista_Final,n_linhas);&#xa;                operador++;                &#xa;            }        &#xa;            token=strtok(NULL,&quot;-&gt;&quot;);&#xa;        }     &#xa;    }	&#xa;```&#xa;	&#xa;- No trecho de maior custo da função, o While irá ser responsável pela tokenização da lista de compras (usando o serapador &lt;strong&gt;-&gt;&lt;/strong&gt;) e a partir disso chamar a função Consulta_Menor_Preco para cada produto. No While mais interno, a cada produto na lista ele entrará 2 vezes, no qual a cada vez realizado o loop o custo será de +4 + o custo da função Consulta_Menor_Preço.&#xa;&#xa;- Portanto, o custo dessa função será similar ao da opção 2, contendo o acréscimo no custo computacional referente a essa tokenização  &lt;img src=&quot;https://user-images.githubusercontent.com/78819692/132346310-54da7b5a-8b3e-4cf5-b018-34597389d542.png&quot; width=&quot;100&quot;&gt; , sendo:&#xa;	&#xa;	&gt; N o número de mercados cadastrados;&#xa;	&#xa;	&gt; P a quantidade de produtos cadastrados em cada mercado;&#xa;	&#xa;	&gt; K a quantidade de produtos escolhidos pelo usuário.&#xa;&#xa;	&#xa;&lt;h1&gt;&lt;/h1&gt;&#xa;	&#xa;#### Opção 3&#xa;&#xa;Na opção 3_(GERAR ARQUIVO COM OS MELHORES PRECOS) teremos a função ´Gera_Guia´ no qual irá criar ou subscrever o arquivo Lista de compras.txt com os resultados obtidos&#xa;	&#xa;&gt; :exclamation: Trecho de código pertencente a função `Gera_Guia`:&#xa;&#xa;	&#xa;```sh	&#xa;	&#xa;    while(cont_produtos&lt;l-&gt;tamanho) // entrara P vezes, P=qntidade de produtos na lista de compras&#xa;    {  &#xa;        char gera_linha[MAX_TAM]=&quot;&quot;; //+1&#xa;        char separador0[MAX_TAM]=&quot;   [&quot;,separador1[MAX_TAM]=&quot;\t\t[&quot;,separador2[MAX_TAM]=&quot;]&quot;; //+1&#xa;        int cont_op=0; //+1&#xa;        &#xa;        while(cont_op&lt;3) // entrará 3 vezes //No primeiro (loop = +7) | No segundo ( loop = )&#xa;        {   &#xa;            if(cont_op==0) //+1&#xa;            {   &#xa;				strcat(gera_linha,separador0);  //+1&#xa;                strcat(gera_linha,l-&gt;best[cont_produtos].nome_produto);  //+1&#xa;            }&#xa;            if(cont_op==1) //+1&#xa;            {   &#xa;                strcat(gera_linha,separador1);  //+1&#xa;                strcat(gera_linha,l-&gt;best[cont_produtos].Market);  //+1&#xa;                i=0;  //+1&#xa;                &#xa;                while(i&lt;n_mercado) //entrará N/2     N = números de mercados&#xa;                {&#xa;                    if(strcmp(l-&gt;best[cont_produtos].Market,Ranking_Mercados.best[i].Market)==0) //+1&#xa;                    {&#xa;                        Ranking_Mercados.best[i].valor=Ranking_Mercados.best[i].valor+1;//+1&#xa;                        break; //+1&#xa;                    }&#xa;                    i++; // +1&#xa;                }              &#xa;            }&#xa;            if (cont_op==2) &#xa;            {&#xa;                strcat(gera_linha,separador1);&#xa;                char convertido[MAX_TAM];&#xa;                strcat(gera_linha,&quot;R$&quot;);&#xa;            	sprintf(convertido, &quot;%.2f&quot;, l-&gt;best[cont_produtos].valor);&#xa;                strcat(gera_linha,convertido);&#xa;            }&#xa;            strcat(gera_linha,separador2);&#xa;            cont_op++;&#xa;        }&#xa;        strcat(gera_linha,&quot;\n&quot;);&#xa;		fputs(gera_linha,arquivo);&#xa;        cont_produtos++;&#xa;    }	&#xa;	&#xa;```&#xa; &#xa;- No trecho de maior impacto em relação ao custo computacional dentro da função, teremos esse While no qual tera seus loops K vezes, sendo K = Produtos Escolhidos. Sem contar com o While interno, temos que o custo dele será de +7 a cada loop.&#xa;&#xa;- No Segundo While, interno ao primeiro, temos que será realizados 3 vezes seu loop. No primeiro loop, atendendo ao primeiro if, temos +7. No segundo loop, atendendo a condição do segundo if, teremos o custo de +27. No terceiro loop teremos o valor de +8. &#xa;&#xa;- Portanto, somando os valores desse While por comppleto, teremos o custo de 42, sendo assim portanto &lt;strong&gt;42K&lt;/strong&gt;, K= Produtos escolhidos.&#xa;	&#xa;&lt;h1&gt;&lt;/h1&gt;&#xa;	&#xa;#### Custo total&#xa;	&#xa;- Calculando cada função que irá fazer parte desse programa e, utilizando de uma exemplo no qual o usuário irá utilizar da opção 2, em que ira inserir uma lista de compras, teremos o custo computacional de: &#xa;	&#xa;	![equaçãog](https://user-images.githubusercontent.com/78819692/132768951-074a0a18-a6b9-4d8c-86ef-29c35b217782.png)&#xa;	&#xa;&lt;h1&gt;&lt;/h1&gt;&#xa;	&#xa;#### Autores&#xa;	&#xa;- Lucas Ribeiro Silva&#xa;- João Pedro de Almeida Campos &#xa;- Thomás Teixeira Pereira" style="text;whiteSpace=wrap;html=1;" vertex="1" parent="430OXLAYMfgtic5GREOD-167">
          <mxGeometry x="-80" y="-8560" width="550" height="8160" as="geometry" />
        </mxCell>
      </root>
    </mxGraphModel>
  </diagram>
</mxfile>
